// https://flems.io/#0=N4IgtglgJlA2CmIBcA2ALAOgAwFYA0IAZhAgM7IDaoAdgIZiJIgYAWALmLCAQMYD21NvEHIQIAL54a9RiB6w+pAK4AneKQwArcrwFCRTBGwAEAUQCyABQAqATQD6AeQBCAKVMBha8YC8x4JIAOtTGxgBKpgBi9gDKAJIAcgDiADKmvsYAjHjGAPS5xmqExgDuEGwsxrTGpBDUAOYIxlB8YMbUfFDwwaER0QCCYWH9thloOfmF8MVlFVUhtCoqtACexp3tneo94VH2loOmCd5+ABwTBUWl5ZXVPCwkUFOEOzEAakn2CTEZgSDsbAADkh8iUwRgSgBmDB8FT1XIAJiwyNypAAbvU-ngdgARRzmfZhRyWGL2HFxCJeOJvUw-PzAHahUjwBA8IRQJDGQEqPiAnEQNRsiBo+AACj+zNZ7L+AEpsSFQsZ7vAeABreAcrk8vkClVsYViv7KtUa2XyxXGNG0WBKeCc7m8-mC-Ui8UgK027ogOWM4x1ajwFQACWs5hS9u1Tr1Brd-sDIbDZp2QQVOKi-QAqilrPYjm8MgyFaEIKQYhjOYRrczzYqoLqhSLSJy8QTLESSWSKZ5rNTaTWU6FHAl7BFzI4aXTjBQALo1scZ46JJIZGc1gAaKUSAGkvpO-gDgaDwVCYXDcpkAJxX3IAD1gdVVWJ233s-Ws1jCk+ANRYfBKnI3bddxyWg2SUWghAAzcEh3b4chYIooKA75jAHYwEgzcwMmyHY3jsSxTFzNJzCOE4shrPDbAI+xIgXKkhwyBEKPwwiPHxSwh1IsYaw8FJHBiDMInsaxHHsDwrAyAMSmMAB1eBaFVcxaEBUUfQVcTLGE0TeP4wT0j8KTZPkxTlNUnigziFIcUnQy5IUpSVLU0I4hxDJ7F8AA+YxRQw8wAGo-JlDA2D4GI2BUOp6jMnYOl5NzPP8NCS0iEI-BvBK2BWQF4D4Yp0p8ArjAAckIJRqCFAQiprEswpUDJ8q8zLsty4x8sKorSHCyKqp2EtHAAI00eqEvSgBCQrqCUWBYGMAAyWbjCanK8t8dq+EGvUeoVEt+iWYafC83blhWDAdqWVZRRvJy-VIUwwEBTKMh4BLnoKgyppmgAfT6lVWvxK1gZljG+363uMMqumIAMnhB0UzpUUUeBlOaFp4DAEAaOYwawa6SwSAQ7oelYjtWJ6EvhxHkfmpV0eEeo5i8rBqtIFJ5OKPxXq8mrwsp4GfqWlrXsKv5JrAfrAyfbbboQBhBDJg7fuptG0SWv7jEo6jTGI0jmbCYQuhUSIyoq1LQa856lYwFWsvgNWNcI2iEnohJmY8VpAQEYQTA5l6UZp63srtlixPYzjjmZt5rWgN37s9wRrBt+Xzb95LqERjAwD4Mq2BlABuYJgn4ahOuMNo-BYfPqELgQS4EPXM5FDJ2a8ocRwscdaQwQElFIFhRUIPOC+oUryv1ARjD7+w2ByDBZ-uR41GoZHC1CIwtV5UgnoeWAoEXigsGnSvi2KUUHUBTfqb6wbT+1UgqYW0aKbPu+-dGm+N4wKe+fX8+u9vmUZS+nnjvReGBe4QEIGwVSR9jAsiBs-DIFgbAOBcO4LwlcdgIJ8EA7eu9hC00xpULymRfShAAPz+GMLPP+G8cjALwSEcQpDjCcnoaAjG9NKhgxIUWRUFDvzUOfnQ3Bi9WEiOEPvacqFmERg3hghUkxASLCBmwWgmJton25gjKeAD-C+jXtAfKxgp6nWoF0G8jhCCiiKhgIqg9eEQO8gAP0McvZha95C0FIKQBIMg3JsDAfeHgYpDHGD8lkIKahASwFAmKXIgRAgYFyPUHIRViqAN4aEZ+GBPHeIyNk3Jm8KGFN8QwMJxUKnhNqpFd+v9CnI1YTE7xpT4AwItF-PwJjSBBLFEzP0UArptOkbwjpxiTAgyKnWNERUYFMKrgqNQbBVAhG0DeUUU8chCJ-hodUKx7FzOCCPE2xhVnrOntsnIuy3EaO8rs4w40-BXMWghP87R4DSVMEsWEbo4jUA9NAdCtAEjGF2bKGBa8A622wQ40sPMdHMIofbIiFhSIyJupHe8UAY4ewDPHG2ZyMkWnIerYObErBh2sGi1OBKEUkqog7OiPYhxoohtMOoGoYGONFJCtWrKoYamRhUHk0lDKfJ5AjP4vz-lPDePjLoi0bZgp2Is5ZejeGQprKEDZvpdmaoucmSuBzyo1xMJEZY9RZbe22QlAp4jqDyKOWPEImds7co6F0TZiwvY4laHK+AOReROs3vScQ1zQiBogDXDAjR1rWj1rvWg0k-ARqjTG-qcaNTLGkg8y0fAAVYGMBQlNxdo0KHTbAeNWaWGLRULacF8ATBqATUm4xCVF4GzdVsT1i82A+rAH6gND1I3F3saEJtWboHKobaq8dibDVD0dcOqYZjAydo9VyL1gg+0DvWEOmuBZQ1qtCF0fqSh6j1EDPWxtfA+BsD1uzDdPbt1bAwAAElfQRHsOYWxt0iHq4QaICxUNnmmSImZsy5gSPmNCoQ00ZubRkYtGg4MVszYm+5hU0R5qeAWote6S0ocrehisVZWlD0HBtNkGAvG1HqGnADGA6zOgNKQQdQbGP1hdOoexvUT48lvfe1a7QPphsVGvK4fgXWCD9Wu-1sC-k5EI2hkoo7FRKKfb6l977P1xG-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-YuVBdvspqHgvdVkvWPbAK2WQUDHfX-Z3X4BnSwKluloaKGWHtVmVgGaEO3T-Vg+sEPbg2g6A33SPX5fDQ1ng+jWg8fRnr6IgxiVxo0fvYFoXTTiXY3T3bQricbefiEKbSAebZQfjNQLzVybbU6YLcI6I+dCLaXV0BrWpo3iwFfWnEnl3m8t3euqLb-bVgA1vRLSbVLWbR+SfI7SBYbMbE6uI-bbNGY-rIGPqSbIPRw-I67bwqw9wQ3ZTVPL7ZfuJvY4bKbB42wK3SYL3FnDvBmICFANzr4EVgEylGAr+FNFAFEzE0ILPQ9gGRQizok+Eyk2k9zs45TVsqwzaQGZyJDLQFNGwDEMk5E9E0U97aU+7UXRvEjlyvkw0+k2LZNR4u6SJdTfgy4wrtAH5XWbRXxNGYRPRfGabnnTNilDFYqFyhM5fE8NTIjPmc2efA2VAKRfPWfqqog23i7ooxpqDWQ5QtQguc-Pdq0zTqhFcxOXg0ZngzdkQ4A8ucpgGTQ-Mi7uRSMxkLk2nGU--K2YC1uScwGWo5cwGXuVSWc-ffQu1WDWg3AzvPen5R80i1Qy7qHpMHJBsapdsXydUIZFcHUOsCoAbMYCcdlnLIg+oFsbJQUGfIGM8VMNErEkqCwLQA0BcS2DYdsFlqs7ecUDmhi1AKiZNQvbw7K1fqVbfuVTrHg-Qli2qw+QnmFZDWgyQUStA14Ui1K6i76XI71sa4Y4QFAxnmffE-K-wxaEoYa1qY7V+bilAoXffG6+7N+cUzY27Zowrp48M942wL48af+QE4BX4CawnqE67rE7G9GyoPVQLkLrXgnvHQjX4ABnLlm6nkrrC36sbTNtDsyGbvjmC+00MsExroDQs11QVQPVK4JjmkPtYaeQGeecq1edYOM+K5yEPgO21dq51aBXVvq6fZqYSZLda7QwIyY95IXYNaosNS1MbtTKLau-y8Ehu2zb6Mw0roXTwzOkY4uzA4exNSvYXRvRXUeVXTPgNssT0GsaYDeCqDnQXtQGsPwLHMIM5qQNlDwBAnZeDNQJ7kqFsK+6CX9eB7lcvkZriXrpMP1adcXGu3u8UMbiDDdLzcft-CrZAbQUcxHpyjzdbcxfI+zp-UdQwyxnnRg4FtacXdw5bSfCxx-EvVCQDswrR66px3Uv-VK+vWxxezLUI+yUTGIyR6fhaScaYKBH3DKeazkHDnZnKR5HxxB0dSpyMzo2A3ag2SujeLOLidPsY9zayTqQk5Y4abJ4wfse6UqPdBxQxcOXM72VOTogPWswtD5X7Fs4CE9K5xQD5Qc5NV0EYLbHWWF1OY2a2XRdpFM3pIxoYUIEF6HnyfxzbQuUhwBquf84qDl1AnG9zgZyQ9K7owV9LVqSWO624Q5+qt5wEiV4x5V6i2FsEHPnZ+PIg8g63sWyw60+w6+UFno9BcA3rvQe8lC0o0lS9pcxo2N9o+NweUAyHuR8u7N5CYVNbuNdy8EgiUN+ulJFi88Ejm16t-l38l17DfK2d+ez1waX10oyowt-5jujg3Sew8iQZ3e185XbvtFoS7bAGJsWpYsmoAaM8mD-gTUBAP1PeA0MYMcbCLbBULbKLry3STsJMKbrAiKIIOBNNGsMZXwCKE8Dpa0LD7oUsM5kK34V7DsDN-Zg7m0Q2gkPgTEIj8j1FNblejjyPRkGI99yPfhRUKpv44QCo8C4vXaoL1JI+V5hkEzL6KLsr1amr+4+8qYGYl3SoxL5UMRThLwqLnr0M6LsiUb0RVkIL6t7e8M+d498Ps8A5LBSUNvLbLbZr8YAADwG0W9+wa+qIq8B-DMW9+18bTAqMUAh+LBsBNk30wmTXx9eYBStkHF1B1oLt2neRFCx-m9mJJ8QPWFF9QCEWEWZ96DZ8WtA6ZXbsN3Ilx87ya+HyBtmkG9GdK+h+J8D2sN3Jgze1PKEmi5bkF9Gdp999oE7cPrN898J9NlJZN4t4ZYwsg0w1Iu3sBnaM7+Ytw1nM4tnN4tEqh4L-p9+StlT8Z+1k1+TR1+kEN-muIY7zN-l-t869Btd90kUBSQW8f959rGL6Qfl7XNYYAR+veffg+gn4-93+rZF3mawYS-9dexfBvIDQG5r80GJ3NFlvxG5799O+AjVmgyP4u4T+FoM-igIr5V9IBUAC3pX2r6CBa+addjvn2mAORBiuuWdmwOUgHpWy9LUUAYhf5QBNeucP0P7wboW9RBEAAKIc0b7DNm+EAAAWc0ZpgC7kPHTga824GAgW+IzcAfABWBL8IA0lYZC7hPrDIO+7PMXkgPP7T9eEBiAZF3UppqCIGwxIoA5GQFBs9BBg6tA9gHqhJ1Bt9GgZ3yb5GdDESgi0GP3rzJsZeoQgZOEMVAICxKP-GwUv2hZYCN+iLM5tvzQa78chUA7FmPjQZkDFQoeOErvR8zYDgss-RTA2mTyMdC+rfXvgc1bIX022oAqrgPAVbk8RQx3DIVoygEgN4OunVbpENd41d08WWGASPT2amdJIH0DwjOxn4lAty8-d5G32XpHUZMjvdbt8027MIyh-mD7sniqHLDdGpuOoVMKQFT9mhufBIWsN7438bqRXNeGjzUAO5A2QfP3ho0N6SVjeWQWlOcNex6c94f-fXuEkyCkU0UAYNnmngVCe8SA3vGweII0aR8-GbdWfhsJ3J-YrBII+4YvwB76MLQqwkoOsINr3p3MO9Q4ZUI0bndXh8AUmrWzxEX8VqpQL3t5Cn7Ijy+7OUYXLxiGwDGhi-AejyICEp8uBGlXoRcx3SjDQ8V3V-pPwFFeYzOowjeoVwiEKi2Ajwx-rDUM7wMheLdbrgul64hAqmNTOphE1SaNMMugIbIFyARCY0T41otWICDtGkcQgAMZkDAn4Frw7kVLZ0VHztyZAKAuyKRDmmdFBj9BpFV0TWhz5PC5Wqqd0b1me7HIz49HV0GfFExdsqiuneIl7GMzWhbQ1hHMYIAoBnwl+HoGMU6z1QnMix5yCmvmLkx956x1hC+nrVtg5pGxnoQ5jWJLHagl+dYz0DayAJ6o2uNYnIPYELGUcexvIPsfMIzz9gfqhyI0Rz0+5-Z9u0WLlFrVVhgwZq9+UwNAStYP0ugtXDcfFi3GFRb8gwYYLYH3HytARoNdrs3wPhhY+q0farGeL8C9sKq1gG8aqjvEyZW20wO7sTmFQaMzA+1N0BmGoCqg-wfDevKrFDrhJXAMQIcGAi6gCtCA3Ja3PskNEvcQgpucyl7H-GAS98r44KInG3FIFdxP4i-Ee0TwW5YR07Jdu13fEXlLxIwaiXhNxz0TCCInCRE+OPGkSWJn40iBxOXEETfsPE+XtVUAksi7qoEx6gdUgnQSSgsE4oPBIELhIBeBo36kuNNxc97MPPJHjUjXG8ZWBb48ieeMokoE9x41B1vnRfTQjamvPSKAJLMlkTA4FE4UleNEl6TuezkhoA+KM68TqANvE3qRVcnMSLJH4vYCq2OA+TOefkoyQFIAkDxZJLye6h8nAl-AlJME54FNWMAITjASElCYtkigQJMJgE7CTpNwmDV4SFQvzP9zeQGT-J9Qe0W5KElWTyS7OQ3KYk8xsBnA0wdHu1wLqJS+ez4wRu1KimsSRS148ajqPF4KclOoocEppwnqUiJRuY3llUOalJTWpihcaUxM3FTThJcUy-AcI2mCAKu6rXRo5MMljTaup+OSXtXFQQSoJuUq4OpPKTFSEgqEiKOhIqkDw7uSYp1OpQp7wALp5yEyTckikeTLJpJKiZfh6ndD4A09YaSxQilHTYZ0UryexLmmVdQEi0+4MtPuCrSxRYMiGcImiIHSrOMMqFHDMvJfj9x4o+qT2iunitqZRrK-OlPklZSQAOUlSXlM+maSZJWOWfDhOORRIUGFMmkbo2lF751pLMzaS7xqErjCC0o1TMjOlnSiFxw8JceiU4wMcWgYAIIpak2SscCueuL0UwR9H-V-4Z0k+DbPqwcZmMjYQseHSYzRhGw4YgwRnF05GyTZm05+N7PCm3D+s4skGfQwNmNhRQ-syjicIpznx2GCc1jMh2ixWyTAjsqSMnP9GihHZDGD2ZiTdlohnZns9QMHPrZEzY5wRWse8mTnByk5t8YOaqJMF0sdCAg62foJ2LDNs59s25J3Kpb5yo5zLamG-Ezm1z-4RckuZiXLltcq5ps7uY3ODHNyw51U45CV1THqAY5rQAOZdJxIWy05bc70f3NtntNe5uc4+U7ILmMNJ5V8ljDPJ06uo55gcxeRGOXnaTFxNU6orUQij1FN5T83eeXUB4PtgeOwfgVaDqiOybSZ8kAX4D+CgoBCIMGBQVLkB2pQ6iCi+YPJdncYoOjA+-gPV2SoSE+pAGSDcDdACBZQZFV0ts2MA4Ulw2FRwAuFwpJBQpJFVsv-LYDezgofAFIH+EDAeAvEYoGUEv0nx+xwywxcMpaXjpE8oEQcpedWlkURiFh5BQkhWxbBZ0f5X7LecbLjkgp9BZsjePXKdnSEkgb8sWavIjlKN1FiPL9o0XYXxzWOouZOQSMm4h5LZbc8BborWBUss5ds0-FyiQVwL9BaCn6AEpQW48EFISjBe7KHkvws+eC30B4o7H60F5Bi4MUMg8X9jklPi1JYopYHFN6xGGA2q2ObEOz9BhCsbCQoqBkKq43oQ5v02C5+BaFWFJpcwt+G28IRxg9hZwpCg8L88KgfhcyFUjCKXFVaJWPmWKT3RJF8AaReIybE+CIa9YqBnazQaqL8QVi3+Vop3nnJdUy3esRvQjrhE-mTrUWaEH4GOzHFvivJcwlCXwK+Y1yzuWDCNCoKIl9yrxcNmiVYLN430V5V3OyXnwWst-XBRWJWalKToXOCpaQr+DkLalkXbeZOIIU9LeF-SgRUMrmHTQlFl7LLOwpqwaV1lmiq5GnS1HAyl0qy8wHioy4sgQI38vMZ6DU6J02p3KApWDDkK9NT8LIMcuSrFDyUVAOQP4NdUYk0zyxdM-6KRnZzsrkZnK0UNyo5mX4MlMgIDjy2zKJ1hiL4N8B+BiAUBuVUiTkOdWhj995VSiYJIUvA6QwLqE4jld-OsVCBvg-2A1bEipXhQaVBYjFZzItDsqK2kq7lU6rFqErhkxK8eCFCLLUVSy5ZZfF6XeSiYRc9JDShkFbijgO4PFD2I5G-ixRAQeqMRfSFeUnVgBei-Yd5Xi6+V8sAVUlKHASCqsssdzLKm0wOypkYMioUKgq3DUlA-KyM0ymAHEnHVNgvIbFtIvuw3o01AZF6uOx5Xr9AatVAJn5RK6ch3ICsO+uGmjVgzJ0nzQFrTjwZis0qtFeKjxXmbhkFGSLU5YfKYIQBVeUg-3nqIkp0wpKfoGQQqxdxtd2KDZMzkgjsBOA3A3YQYccqK77rOKlkBKlFwbTzl7oH6luUizVaTKjK1BMGW2o7VLqkWZgrUU6xgSgKlxLORGGwCuiX4JFJiaZc5n+ipQvI0yhKISUID0Y0QoeFpW5V7iZdM+6GsHB2ibWigBEc8WjQglDTkaGFmFZhUmtg1A5YKoQCjd3Co27qhkbIG8HRtXQMamNOSFjbfFQgAIhkAm3kDxpiJRjwyhqbgLwUMImxyATATILgCQA4AEQEgKQCADoAMBRAWgHQHID0BexRAHiI6ieqHj+MEMkmXTjsD7j9BAQgIa6Ez0EAw5OgKwGsN+EnwkZyCcySonB083JrosfJPuJMmFBbQLQcWwEFVGKg55pofAOxHqji31EQo1AVLd+BKJBJVQnIVSERtv7ZwwkfgTIDOWUyqRbWkgYqHUB4B2JfaOsyYM5rRzbkbaHmrzTkG-B1BygnIHAHJpyC+aAk-UALf1qAU75k68hUNPIkmCRavNjGnYuUDk1qpJgoQDrS-mtCJsMmXpO4JFTUAmEttHOV0g5uzLUBygi2goHGIvxlaFYmWM7aEDi1TItoL2xUHFpYCZBUt-AbOGpE+2vbRQPqJQEjzkzfh-tcsUNPKCB0TxRQ1gCKNEgh1QdKtMO4IHDpy0508tBW9YOVGK2lbSZGOu7Wcyh0mA-I1WyuHDu22XA6t9iOHeFka1FRmtxlL2K1uoCfaMkZ2+nQUAGwFBJgtQe6E0D-Y4pjCxOulkuNB3g7VtZOjbYWDO2xbrELABEH9oc1rE7RVO3nUPEmAC6E8pUGaCLu-KnaCgcHRHRAGR1lb5dJOhbGTgVwKAooRUcwEdU2Jm7kddiW7YqDriQbXQj2ryFbrYo1xbd6MPgA7sgme4XdSOhAO7vF2kFKiCuiajLoc2HoFY32yEKrsq1rFIQPO1CBpslDRga4ogC8EgEyAAB2YzdIHM1MAck3iDTQcVs1MAJA04cQEAA
// https://github.com/yelouafi/petit-dom/blob/master/examples/diff.html

let EMPTY_OBJECT = {},
  REF_SINGLE = 1, // ref with a single dom node
  REF_ARRAY = 4, // ref with an array od nodes
  REF_PARENT = 8, // ref with a child ref
  SVG_NS = "http://www.w3.org/2000/svg",
  DOM_PROPS_DIRECTIVES = {
    selected: propDirective("selected"),
    checked: propDirective("checked"),
    value: propDirective("value"),
    innerHTML: propDirective("innerHTML"),
  },
  DEFAULT_ENV = {
    isSvg: false,
    directives: DOM_PROPS_DIRECTIVES,
  },
  ON_REMOVES = [],
  MOUNTING = [],
  XLINK_NS = "http://www.w3.org/1999/xlink",
  NS_ATTRS = { show: XLINK_NS, actuate: XLINK_NS, href: XLINK_NS },
  NUM = 1,
  VTYPE_ELEMENT = 1,
  VTYPE_FUNCTION = 2,
  VTYPE_COMPONENT = 4,
  CLOSURE_TO_CMP = new WeakMap(),
  CMP_TO_CLOSURE = new WeakMap(),
  CHILDS = new WeakMap(),
  ID = _ => (NUM++).toString(),
  noop = _ => {},
  isFn = x => typeof x === 'function',
  isStr = x => typeof x === 'string',
  isObj = x => x !== null && typeof x === 'object',
  isArr = x => Array.isArray(x),
  isEmpty = c => c === null || c === false || c === undefined || (isArr(c) && c.length === 0),
  isNonEmptyArray = c => isArr(c) && c.length > 0,
  isLeaf = c => isStr(c) || typeof c === "number",
  isElement = c => c && c.vtype === VTYPE_ELEMENT,
  isRenderFunction = c => c && c.vtype === VTYPE_FUNCTION,
  isComponent = c => c && c.vtype === VTYPE_COMPONENT,
  isValidComponentType = c => c && isFn(c.mount);

const m = h;

const onRemove = f => ON_REMOVES.push(f);

function h(_t, ...children) {
  let props = children[0];
  if (props && isObj(props) && !isArr(props) && !(props._t || props.props))
    children.shift();
  else props = EMPTY_OBJECT;

  props =
    children.length > 1
      ? { ...props, children }
      : children.length === 1
      ? { ...props, children: children[0] }
      : props;

  // parse tag
  if (isStr(_t)) {
    let idx = _t.indexOf('.');
    if (~idx) {
      let className = _t.slice(idx + 1).replace(/\./g, ' ')
      props.class = props.class ? className + ' ' + String(props.class) : className;
      _t = _t.slice(0, idx);
    }
    _t = _t || 'div';
  }

  return jsx(_t, props, props.key);
}

function jsx(_t, props, key) {
  if (key !== key) throw new Error("Invalid NaN key");
  let vtype =
    isStr(_t)
      ? VTYPE_ELEMENT
      : isValidComponentType(_t)
      ? VTYPE_COMPONENT
      : isFn(_t)
      ? VTYPE_FUNCTION
      : undefined;
  if (vtype === undefined) throw new Error("Invalid VNode type");
  return {
    vtype,
    _t,
    key,
    props,
  };
}

const Fragment = props => props.children;

function mount(rootFn, parentDomNode, options = {}) {
  let rootCmp = {
    _t: {
      event: fn => ev => { fn(ev); redraw(); }
    }
  };

  options.globalRedraw = options.globalRedraw === void 0 ? true : options.globalRedraw;
  if (isFn(rootFn())) rootFn = rootFn();

  function redraw() {
    debugger;
    MOUNTING.push(rootCmp)
    render(rootFn(), parentDomNode, options)
    MOUNTING.pop();
  }

  redraw();
  return redraw;
}

function render(vnode, parentDomNode, options = {}) {
  // debugger;
  let rootRef = parentDomNode.$$PETIT_DOM_REF,
    env = { ...DEFAULT_ENV },
    globalRedraw = options.globalRedraw !== void 0 ? options.globalRedraw : false;

  Object.assign(env.directives, options.directives);
  // debugger;

  if (rootRef == null) {
    let ref = mountNode(vnode, env, globalRedraw);
    parentDomNode.$$PETIT_DOM_REF = { ref, vnode };
    parentDomNode.textContent = "";
    insertDom(parentDomNode, ref, null);
  } else {
    rootRef.ref = patchInPlace(
      parentDomNode,
      vnode,
      rootRef.vnode,
      rootRef.ref,
      env,
      globalRedraw
    );
    rootRef.vnode = vnode;
  }
}

// non exports
class Renderer {
  constructor(props, env, globalRedraw) {
    this.props = props;
    this._STATE_ = {
      env,
      vnode: null,
      parentDomNode: null,
      ref: mountNode(null)
    };
    this.render = this.render.bind(this);
    this.globalRedraw = globalRedraw;
  }

  setProps(props) {
    this.oldProps = this.props;
    this.props = props;
  }

  render(vnode) {
    let state = this._STATE_;
    let oldVNode = state.vnode;
    state.vnode = vnode;
    if (state.parentDomNode === null) {
      let parentNode = getParentNode(state.ref);
      if (parentNode === null) {
        state.ref = mountNode(vnode, state.env, this.globalRedraw);
        return;
      } else {
        state.parentDomNode = parentNode;
      }
    }
    // here we are sure state.parentDOMNode is defined
    state.ref = patchInPlace(
      state.parentDomNode,
      vnode,
      oldVNode,
      state.ref,
      state.env,
      this.globalRedraw
    );
  }
}

function mountNode(vnode, env = DEFAULT_ENV, globalRedraw) {
  if (isEmpty(vnode)) {
    return {
      type: REF_SINGLE,
      node: document.createComment("NULL"),
    };
  } else if (isLeaf(vnode)) {
    return {
      type: REF_SINGLE,
      node: document.createTextNode(vnode),
    };
  } else if (isElement(vnode)) {
    let node;
    let { _t, props } = vnode;
    if (_t === "svg" && !env.isSvg) {
      env = { ...env, isSVG: true };
    }
    // TODO : {is} for custom elements
    if (!env.isSVG) {
      node = document.createElement(_t);
    } else {
      node = document.createElementNS(SVG_NS, _t);
    }

    // element lifecycle hooks
    if (isFn(props.oncreate)) props.oncreate(node);

    mountAttributes(node, props, env, globalRedraw);
    let childrenRef =
      props.children == null ? props.children : mountNode(props.children, env, globalRedraw);
    /**
     * We need to insert content before setting interactive props
     * that rely on children been present (e.g select)
     */
    if (childrenRef != null) insertDom(node, childrenRef);
    mountDirectives(node, props, env);
    return {
      type: REF_SINGLE,
      node,
      children: childrenRef,
    };
  } else if (isNonEmptyArray(vnode)) {
    return {
      type: REF_ARRAY,
      children: vnode.map((child) => mountNode(child, env, globalRedraw)),
    };
  } else if (isRenderFunction(vnode)) {
    let childVNode = vnode._t(vnode.props);

    if (isFn(childVNode)) {
      let cmp,
        view = childVNode,
        id = ID(),
        cmps = CLOSURE_TO_CMP.get(vnode._t) || {};

      vnode.id = id;
      cmp = toClosureCmp(vnode, view)
      
      cmps[id] = cmp;
      CLOSURE_TO_CMP.set(vnode._t, cmps);
      CMP_TO_CLOSURE.set(cmp, vnode._t);
      return mountNode(cmp, env, globalRedraw);
    }

    let childRef = mountNode(childVNode, env, globalRedraw);
    return {
      type: REF_PARENT,
      childRef,
      childState: childVNode,
    };
  } else if (isComponent(vnode)) {
    let renderer = new Renderer(vnode.props, env, globalRedraw);

    let parentCmp;
    if (parentCmp = MOUNTING[MOUNTING.length - 1]) {
      let child_closure = CMP_TO_CLOSURE.get(vnode),
        childs = CHILDS.get(parentCmp) || [],
        idx = childs.length;
        
      // attach method to remove self from parent
      vnode._t.removeFromParent = _ => childs.splice(idx, 1);

      childs.push({
        id: vnode.id,
        vtype: VTYPE_FUNCTION,
        _t: child_closure
      });

      CHILDS.set(parentCmp, childs);
    }

    vnode._t.mount(renderer);
    return {
      type: REF_PARENT,
      childRef: renderer._STATE_.ref,
      childState: renderer,
    };
  } else if (vnode instanceof Node) {
    return {
      type: REF_SINGLE,
      node: vnode,
    };
  }
  if (vnode === undefined) {
    throw new Error("mount: vnode is undefined!");
  }

  throw new Error("mount: Invalid Vnode!");
}

function patch(
  parentDomNode,
  newVNode,
  oldVNode,
  ref,
  env = DEFAULT_ENV,
  globalRedraw
) {
  if (isObj(oldVNode) && isObj(newVNode))
    newVNode.id = oldVNode.id;

  if (oldVNode === newVNode) {
    return ref;
  } else if (isEmpty(newVNode) && isEmpty(oldVNode)) {
    return ref;
  } else if (isLeaf(newVNode) && isLeaf(oldVNode)) {
    ref.node.nodeValue = newVNode;
    return ref;
  } else if (
    isElement(newVNode) &&
    isElement(oldVNode) &&
    newVNode._t === oldVNode._t
  ) {
    if (newVNode._t === "svg" && !env.isSvg) {
      env = { ...env, isSVG: true };
    }
    patchAttributes(ref.node, newVNode.props, oldVNode.props, env, globalRedraw);
    let oldChildren = oldVNode.props.children;
    let newChildren = newVNode.props.children;
    if (oldChildren == null) {
      if (newChildren != null) {
        ref.children = mountNode(newChildren, env, globalRedraw);
        insertDom(ref.node, ref.children);
      }
    } else {
      if (newChildren == null) {
        ref.node.textContent = "";
        unmount(oldChildren, ref.children, env, globalRedraw);
        ref.children = null;
      } else {
        ref.children = patchInPlace(
          ref.node,
          newChildren,
          oldChildren,
          ref.children,
          env,
          globalRedraw
        );
      }
    }
    patchDirectives(ref.node, newVNode.props, oldVNode.props, env);
    return ref;
  } else if (isNonEmptyArray(newVNode) && isNonEmptyArray(oldVNode)) {
    patchChildren(parentDomNode, newVNode, oldVNode, ref, env, globalRedraw);
    return ref;
  } else if (
    isRenderFunction(newVNode) &&
    isRenderFunction(oldVNode) &&
    newVNode._t === oldVNode._t
  ) {
    let renderFn = newVNode._t;
    let shouldUpdate =
      renderFn.shouldUpdate != null
        ? renderFn.shouldUpdate(oldVNode.props, newVNode.props)
        : defaultShouldUpdate(oldVNode.props, newVNode.props);
    if (shouldUpdate) {
      let cmp,
        id = oldVNode.id,
        cmps = CLOSURE_TO_CMP.get(renderFn);

      if (cmps && id && (cmp = cmps[id])) {
        return patch(
          parentDomNode,
          { ...cmp, props: newVNode.props },
          cmp,
          ref,
          env,
          globalRedraw
        );
      }

      let childVNode = renderFn(newVNode.props);
      let childRef = patch(
        parentDomNode,
        childVNode,
        ref.childState,
        ref.childRef,
        env,
        globalRedraw
      );
      // We need to return a new ref in order for parent patches to
      // properly replace changing DOM nodes
      if (childRef !== ref.childRef) {
        return {
          type: REF_PARENT,
          childRef,
          childState: childVNode,
        };
      } else {
        ref.childState = childVNode;
        return ref;
      }
    } else {
      return ref;
    }
  } else if (
    isComponent(newVNode) &&
    isComponent(oldVNode) &&
    newVNode._t === oldVNode._t
  ) {
    let renderer = ref.childState;
    let state = renderer._STATE_;
    state.env = env;
    state.parentNode = parentDomNode;
    renderer.setProps(newVNode.props);
    newVNode._t.patch(renderer);
    if (ref.childRef !== state.ref) {
      return {
        type: REF_PARENT,
        childRef: state.ref,
        childState: renderer,
      };
    } else {
      return ref;
    }
  } else if (newVNode instanceof Node && oldVNode instanceof Node) {
    ref.node = newVNode;
    return ref;
  } else {
    return mountNode(newVNode, env, globalRedraw);
  }
}

/**
 * Execute any compoenent specific unmount code
 */
function unmount(vnode, ref, env) {
  // if (vnode instanceof Node ||  isEmpty(vnode) || isLeaf(vnode)) return;
  if (isElement(vnode)) {
    unmountDirectives(ref.node, vnode.props, env);
    if (vnode.props.children != null)
      unmount(vnode.props.children, ref.children, env);
  } else if (isNonEmptyArray(vnode)) {
    vnode.forEach((childVNode, index) =>
      unmount(childVNode, ref.children[index], env)
    );
  } else if (isRenderFunction(vnode)) {
    let cmp, cmps = CLOSURE_TO_CMP.get(vnode._t);
    if (cmps && vnode.id && (cmp = cmps[vnode.id])) {
      delete cmps[vnode.id];
      CMP_TO_CLOSURE.delete(cmp);
      return unmount(cmp, ref, env);
    }

    unmount(ref.childState, ref.childRef, env);
  } else if (isComponent(vnode)) {
    vnode._t.unmount(ref.childState);
  }
}

function patchInPlace(parentDomNode, newVNode, oldVNode, ref, env, globalRedraw) {
  let newRef = patch(parentDomNode, newVNode, oldVNode, ref, env, globalRedraw);
  if (newRef !== ref) {
    replaceDom(parentDomNode, newRef, ref);
    unmount(oldVNode, ref, env);
  }
  return newRef;
}

function patchChildren(parentDomNode, newChildren, oldchildren, ref, env, globalRedraw) {
  // We need to retreive the next sibling before the old children
  // get eventually removed from the current DOM document
  let nextNode = getNextSibling(ref);
  let children = Array(newChildren.length);
  let refChildren = ref.children;
  let newStart = 0,
    oldStart = 0,
    newEnd = newChildren.length - 1,
    oldEnd = oldchildren.length - 1;
  let oldVNode, newVNode, oldRef, newRef, refMap;

  while (newStart <= newEnd && oldStart <= oldEnd) {
    if (refChildren[oldStart] === null) {
      oldStart++;
      continue;
    }
    if (refChildren[oldEnd] === null) {
      oldEnd--;
      continue;
    }

    oldVNode = oldchildren[oldStart];
    newVNode = newChildren[newStart];
    if (newVNode.key === oldVNode.key) {
      oldRef = refChildren[oldStart];
      newRef = children[newStart] = patchInPlace(
        parentDomNode,
        newVNode,
        oldVNode,
        oldRef,
        env,
        globalRedraw
      );
      newStart++;
      oldStart++;
      continue;
    }

    oldVNode = oldchildren[oldEnd];
    newVNode = newChildren[newEnd];
    if (newVNode.key === oldVNode.key) {
      oldRef = refChildren[oldEnd];
      newRef = children[newEnd] = patchInPlace(
        parentDomNode,
        newVNode,
        oldVNode,
        oldRef,
        env,
        globalRedraw
      );
      newEnd--;
      oldEnd--;
      continue;
    }

    if (refMap == null) {
      refMap = {};
      for (let i = oldStart; i <= oldEnd; i++) {
        oldVNode = oldchildren[i];
        if (oldVNode.key != null) {
          refMap[oldVNode.key] = i;
        }
      }
    }

    newVNode = newChildren[newStart];
    let idx = newVNode.key != null ? refMap[newVNode.key] : null;
    if (idx != null) {
      oldVNode = oldchildren[idx];
      oldRef = refChildren[idx];
      newRef = children[newStart] = patch(
        parentDomNode,
        newVNode,
        oldVNode,
        oldRef,
        env,
        globalRedraw
      );
      insertDom(parentDomNode, newRef, getDomNode(refChildren[oldStart]));
      if (newRef !== oldRef) {
        removeDom(parentDomNode, oldRef);
        unmount(oldVNode, oldRef, env);
      }
      refChildren[idx] = null;
    } else {
      newRef = children[newStart] = mountNode(newVNode, env, globalRedraw);
      insertDom(parentDomNode, newRef, getDomNode(refChildren[oldStart]));
    }
    newStart++;
  }

  let beforeNode =
    newEnd < newChildren.length - 1
      ? getDomNode(children[newEnd + 1])
      : nextNode;
  while (newStart <= newEnd) {
    let newRef = mountNode(newChildren[newStart], env, globalRedraw);
    children[newStart] = newRef;
    insertDom(parentDomNode, newRef, beforeNode);
    newStart++;
  }
  while (oldStart <= oldEnd) {
    oldRef = refChildren[oldStart];
    if (oldRef != null) {
      removeDom(parentDomNode, oldRef);
      unmount(oldchildren[oldStart], oldRef, env);
    }
    oldStart++;
  }
  ref.children = children;
}

function defaultShouldUpdate(p1, p2) {
  if (p1 === p2) return false;
  for (let key in p2) {
    if (p1[key] !== p2[key]) return true;
  }
  return false;
}

function propDirective(prop) {
  return {
    mount(element, value) {
      element[prop] = value;
    },
    patch(element, newValue, oldValue) {
      if (newValue !== oldValue) {
        element[prop] = newValue;
      }
    },
    unmount(element, _) {
      element[prop] = null;
    },
  };
}

function getDomNode(ref) {
  if (ref.type === REF_SINGLE) {
    return ref.node;
  } else if (ref.type === REF_ARRAY) {
    return getDomNode(ref.children[0]);
  } else if (ref.type === REF_PARENT) {
    return getDomNode(ref.childRef);
  }
  throw new Error("Unkown ref type " + JSON.stringify(ref));
}

function getParentNode(ref) {
  if (ref.type === REF_SINGLE) {
    return ref.node.parentNode;
  } else if (ref.type === REF_ARRAY) {
    return getParentNode(ref.children[0]);
  } else if (ref.type === REF_PARENT) {
    return getParentNode(ref.childRef);
  }
  throw new Error("Unkown ref type " + ref);
}

function getNextSibling(ref) {
  if (ref.type === REF_SINGLE) {
    return ref.node.nextSibling;
  } else if (ref.type === REF_ARRAY) {
    return getNextSibling(ref.children[ref.children.length - 1]);
  } else if (ref.type === REF_PARENT) {
    return getNextSibling(ref.childRef);
  }
  throw new Error("Unkown ref type " + JSON.stringify(ref));
}

function insertDom(parent, ref, nextSibling) {
  if (ref.type === REF_SINGLE) {
    parent.insertBefore(ref.node, nextSibling);
  } else if (ref.type === REF_ARRAY) {
    ref.children.forEach((ch) => {
      insertDom(parent, ch, nextSibling);
    });
  } else if (ref.type === REF_PARENT) {
    insertDom(parent, ref.childRef, nextSibling);
  } else {
    throw new Error("Unkown ref type " + JSON.stringify(ref));
  }
}

function removeDom(parent, ref) {
  if (ref.type === REF_SINGLE) {
    parent.removeChild(ref.node);
  } else if (ref.type === REF_ARRAY) {
    ref.children.forEach((ch) => {
      removeDom(parent, ch);
    });
  } else if (ref.type === REF_PARENT) {
    removeDom(parent, ref.childRef);
  } else {
    throw new Error("Unkown ref type " + ref);
  }
}

function replaceDom(parent, newRef, oldRef) {
  insertDom(parent, newRef, getDomNode(oldRef));
  removeDom(parent, oldRef);
}

function mountDirectives(domElement, props, env) {
  for (let key in props) {
    if (key in env.directives) {
      env.directives[key].mount(domElement, props[key]);
    }
  }
}

function patchDirectives(domElement, newProps, oldProps, env) {
  for (let key in newProps) {
    if (key in env.directives) {
      env.directives[key].patch(domElement, newProps[key], oldProps[key]);
    }
  }
  for (let key in oldProps) {
    if (key in env.directives && !(key in newProps)) {
      env.directives[key].unmount(domElement, oldProps[key]);
    }
  }
}

function unmountDirectives(domElement, props, env) {
  for (let key in props) {
    if (key in env.directives) {
      env.directives[key].unmount(domElement, props[key]);
    }
  }
}

function mountAttributes(domElement, props, env, globalRedraw) {
  for (var key in props) {
    if (key === "key" || key === "children" || key in env.directives) continue;
    if (key.startsWith("on")) {
      let cmp = MOUNTING[MOUNTING.length - 1];
      domElement[key.toLowerCase()] = globalRedraw && cmp ? cmp._t.event(props[key]) : props[key];
    } else {
      setDOMAttribute(domElement, key, props[key], env.isSVG);
    }
  }
}

function patchAttributes(domElement, newProps, oldProps, env, globalRedraw) {
  for (var key in newProps) {
    if (key === "key" || key === "children" || key in env.directives) continue;
    var oldValue = oldProps[key];
    var newValue = newProps[key];
    if (oldValue !== newValue) {
      if (key.startsWith("on")) {
        let cmp = MOUNTING[MOUNTING.length - 1];
        domElement[key.toLowerCase()] = globalRedraw && cmp ? cmp._t.event(newValue) : newValue;
      } else {
        setDOMAttribute(domElement, key, newValue, env.isSVG);
      }
    }
  }
  for (key in oldProps) {
    if (
      key === "key" ||
      key === "children" ||
      key in env.directives ||
      key in newProps
    )
      continue;
    if (key.startsWith("on")) {
      domElement[key.toLowerCase()] = null;
    } else {
      domElement.removeAttribute(key);
    }
  }
}

function setDOMAttribute(el, attr, value, isSVG) {
  if (value === true) {
    el.setAttribute(attr, "");
  } else if (value === false) {
    el.removeAttribute(attr);
  } else {
    var namespace = isSVG ? NS_ATTRS[attr] : undefined;
    if (namespace !== undefined) {
      el.setAttributeNS(namespace, attr, value);
    } else {
      el.setAttribute(attr, value);
    }
  }
}

function toClosureCmp(vnode, view) {
  let onRemove = ON_REMOVES.pop() || noop,
    cmp = {
      key: vnode.key,
      id: vnode.id,
      vtype: VTYPE_COMPONENT,
      props: vnode.props || {},
      _t: {
        view,
        removeFromParent: noop,
        event: noop,
        mount: render,
        patch: render,
        unmount: _ => {
          onRemove();
          let childs;
          if (childs = CHILDS.get(cmp)) {
            for (let i = 0; i < childs.length; i++) {
              unmount(childs[i], EMPTY_OBJECT);
            }

            CHILDS.delete(cmp);
          }
          
          cmp._t.removeFromParent();
        }
      }
    };
  
  function render(ctx) {
    cmp._t.event = fn => ev => {
      fn(ev);
      MOUNTING.push(cmp);
      ctx.render(view({ ...ctx.props }));
      MOUNTING.pop();
    };

    MOUNTING.push(cmp);
    ctx.render(view({ ...ctx.props }));
    MOUNTING.pop();
  }

  return cmp;
}